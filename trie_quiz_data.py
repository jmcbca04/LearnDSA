trie_quiz = [
    {
        "question": "What is the primary purpose of a Trie data structure?",
        "options": ["Sorting strings", "Efficient string search and prefix matching", "Balancing binary trees", "Graph traversal"],
        "correct_answer": "Efficient string search and prefix matching"
    },
    {
        "question": "What is the time complexity of inserting a word of length k into a Trie?",
        "options": ["O(1)", "O(k)", "O(log k)", "O(n)"],
        "correct_answer": "O(k)"
    },
    {
        "question": "Which of the following applications is NOT typically associated with Tries?",
        "options": ["Autocomplete suggestions", "Spell checkers", "IP routing tables", "Sorting algorithms"],
        "correct_answer": "Sorting algorithms"
    },
    {
        "question": "In a Trie, what does each node typically represent?",
        "options": ["A complete word", "A character", "A prefix", "The length of a word"],
        "correct_answer": "A character"
    },
    {
        "question": "What is the space complexity of a Trie in the worst case?",
        "options": ["O(n)", "O(k*n)", "O(2^n)", "O(log n)"],
        "correct_answer": "O(k*n)"
    },
    {
        "question": "Which operation is typically faster in a Trie compared to a hash table?",
        "options": ["Insertion", "Deletion", "Exact string matching", "Prefix matching"],
        "correct_answer": "Prefix matching"
    },
    {
        "question": "What is a common way to mark the end of a word in a Trie?",
        "options": ["Using a special character", "Setting a boolean flag in the node", "Removing the last node", "Adding a null pointer"],
        "correct_answer": "Setting a boolean flag in the node"
    },
    {
        "question": "Which of the following is TRUE about Tries?",
        "options": ["They always have a fixed depth", "They can only store lowercase letters", "They can efficiently store and search unicode strings", "They require less memory than hash tables for storing strings"],
        "correct_answer": "They can efficiently store and search unicode strings"
    },
    {
        "question": "What is the time complexity of finding the longest common prefix of a set of strings using a Trie?",
        "options": ["O(1)", "O(m), where m is the length of the longest common prefix", "O(n), where n is the number of strings", "O(k*n), where k is the average string length"],
        "correct_answer": "O(m), where m is the length of the longest common prefix"
    },
    {
        "question": "In a Trie, how many children can each node have in the worst case for an English dictionary?",
        "options": ["26", "52", "256", "Unlimited"],
        "correct_answer": "26"
    },
    {
        "question": "What is a radix tree (or Patricia trie)?",
        "options": ["A Trie with a radix sort algorithm", "A compressed version of a regular Trie", "A Trie that only stores numbers", "A balanced Trie"],
        "correct_answer": "A compressed version of a regular Trie"
    },
    {
        "question": "Which of the following operations is typically NOT O(k) in a Trie, where k is the length of the key?",
        "options": ["Insertion", "Deletion", "Search", "Finding all keys with a given prefix"],
        "correct_answer": "Finding all keys with a given prefix"
    },
    {
        "question": "What is the main disadvantage of using a Trie?",
        "options": ["Slow insertion time", "High space complexity", "Difficulty in implementation", "Poor performance for long strings"],
        "correct_answer": "High space complexity"
    },
    {
        "question": "In which scenario would a Trie be less efficient than a hash table?",
        "options": ["Prefix matching", "Storing a small set of very long strings", "Autocomplete functionality", "Spell checking"],
        "correct_answer": "Storing a small set of very long strings"
    },
    {
        "question": "What modification can be made to a Trie to make it more memory-efficient?",
        "options": ["Using a balanced tree structure", "Implementing path compression", "Adding more child nodes", "Increasing the alphabet size"],
        "correct_answer": "Implementing path compression"
    }
]